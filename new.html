<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>أحدث حلقات</title>
<link rel="stylesheet" href="/CSS/style.css" />
<script src="navbar.js" defer></script>
<link rel="icon" href="https://abdo12249.github.io/1/navbar/favicon.ico" type="image/x-icon" />

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<style>
/* Pagination styling */
.pagination { display: flex; justify-content: center; flex-wrap: wrap; gap: 8px; margin: 20px 0; }
.pagination button { padding: 6px 12px; background-color: var(--primary-color, #ef4444); color: white; border: none; cursor: pointer; border-radius: 6px; transition: background-color 0.3s ease; }
.pagination button:hover { background-color: #dc2626; }
.pagination button.active { background-color: #b91c1c; }
.pagination span { padding: 6px 12px; color: #888; }

/* Loading overlay */
.loading-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background-color: rgba(0,0,0,0.7); display: flex; flex-direction: column;
  justify-content: center; align-items: center; z-index: 1000; color: white; font-size: 1.2em;
}
.spinner {
  border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid #fff;
  border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
.anime-image img.loaded { opacity: 1; }
</style>
</head>
<body>

<div id="navbar-container"></div>

<main>
  <div class="section-header">
    <h1>أحدث حلقات</h1>
  </div>

  <div class="anime-grid" id="animeGrid"></div>
  <div class="pagination" id="pagination"></div>

  <!-- Loading overlay -->
  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="spinner"></div>
    <span>جاري تحميل الأنمي...</span>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
import { getFirestore, collection, getDocs, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyAQpXUUOLyN2B6IWGb5Ru2Dl8NZPNimTEg",
  authDomain: "wep1-25124.firebaseapp.com",
  databaseURL: "https://wep1-25124-default-rtdb.firebaseio.com",
  projectId: "wep1-25124",
  storageBucket: "wep1-25124.firebasestorage.app",
  messagingSenderId: "400763524699",
  appId: "1:400763524699:web:b3d5b77815de059ad9117e",
  measurementId: "G-ER2GCC7BK4"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const maxItemsPerPage = 20;
const EPISODES_PER_PART = 500;
let allEpisodes = [];

function showLoading() { document.getElementById("loadingOverlay").style.display = "flex"; }
function hideLoading() { document.getElementById("loadingOverlay").style.display = "none"; }
function getPageFromURL() { const params = new URLSearchParams(window.location.search); return parseInt(params.get("page")) || 1; }
function updateURL(page) { const url = new URL(window.location.href); url.searchParams.set("page", page); window.history.pushState({}, "", url); }
function setupLazyLoading() {
  const lazyImages = document.querySelectorAll("img[data-src]");
  const observer = new IntersectionObserver((entries, obs) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        img.removeAttribute("data-src");
        obs.unobserve(img);
      }
    });
  }, { rootMargin: "100px" });
  lazyImages.forEach(img => observer.observe(img));
}
function renderPage(pageNumber) {
  updateURL(pageNumber);
  const animeGrid = document.getElementById("animeGrid");
  animeGrid.innerHTML = "";
  const startIndex = (pageNumber - 1) * maxItemsPerPage;
  const endIndex = startIndex + maxItemsPerPage;
  const episodesToShow = allEpisodes.slice(startIndex, endIndex);

  episodesToShow.forEach(ep => {
    const card = document.createElement("div");
    card.className = "anime-card";
    card.innerHTML = `
      <div class="anime-image">
        <img data-src="${ep.image}" alt="${ep.animeTitle}" loading="lazy">
      </div>
      <div class="anime-info">
        <h3>${ep.animeTitle}</h3>
        <div class="anime-meta">
          <span>${ep.title}</span>
          <a href="${ep.link}" class="watch-button">شاهد الآن</a>
        </div>
      </div>`;
    animeGrid.appendChild(card);
  });

  setupLazyLoading();
  document.querySelectorAll(".pagination button").forEach(b => b.classList.remove("active"));
  const activeBtn = document.querySelector(`.pagination button[data-page="${pageNumber}"]`);
  if (activeBtn) activeBtn.classList.add("active");
  window.scrollTo({ top: 0, behavior: "smooth" });
}

function setupPagination(totalItems, currentPage) {
  const pageCount = Math.ceil(totalItems / maxItemsPerPage);
  const pagination = document.getElementById("pagination");
  pagination.innerHTML = "";
  const maxVisible = 5;
  let start = Math.max(1, currentPage - Math.floor(maxVisible / 2));
  let end = Math.min(start + maxVisible - 1, pageCount);
  if (end - start < maxVisible - 1) start = Math.max(1, end - maxVisible + 1);

  if (currentPage > 1) {
    const prev = document.createElement("button");
    prev.textContent = "السابق";
    prev.onclick = () => { renderPage(currentPage - 1); setupPagination(totalItems, currentPage - 1); };
    pagination.appendChild(prev);
  }

  for (let i = start; i <= end; i++) {
    const btn = document.createElement("button");
    btn.textContent = i;
    btn.setAttribute("data-page", i);
    if (i === currentPage) btn.classList.add("active");
    btn.onclick = () => { renderPage(i); setupPagination(totalItems, i); };
    pagination.appendChild(btn);
  }

  if (currentPage < pageCount) {
    const next = document.createElement("button");
    next.textContent = "التالي";
    next.onclick = () => { renderPage(currentPage + 1); setupPagination(totalItems, currentPage + 1); };
    pagination.appendChild(next);
  }
}

async function loadAllParts() {
  const snapshot = await getDocs(collection(db, "episodes"));
  const partsArray = [];
  snapshot.forEach(docSnap => {
    if (docSnap.id.startsWith("part")) {
      const partNumber = parseInt(docSnap.id.replace("part",""),10);
      partsArray.push({ partNumber, episodes: docSnap.data().episodes });
    }
  });
  partsArray.sort((a,b)=>a.partNumber-b.partNumber);
  const mergedEpisodes = [];
  partsArray.forEach(part=>mergedEpisodes.push(...part.episodes));
  return mergedEpisodes;
}

async function uploadEpisodesInParts(episodes) {
  episodes.sort((a, b) => new Date(b.date) - new Date(a.date));
  const totalParts = Math.ceil(episodes.length / EPISODES_PER_PART);
  for(let i=0;i<totalParts;i++){
    const start = i*EPISODES_PER_PART;
    const end = start+EPISODES_PER_PART;
    const partEpisodes = episodes.slice(start,end);
    const partDocRef = doc(db,"episodes",`part${i+1}`);
    const existing = await getDoc(partDocRef);
    if(existing.exists()){
      const oldData = existing.data().episodes;
      const changed = JSON.stringify(oldData) !== JSON.stringify(partEpisodes);
      if(!changed){ console.log(`⏭️ الجزء part${i+1} لم يتغير.`); continue; }
    }
    await setDoc(partDocRef,{episodes: partEpisodes, updatedAt: Date.now()});
    console.log(`✅ تم تحديث أو إنشاء part${i+1} (${partEpisodes.length} حلقة)`);
  }
}

// ---------------- fetch JSON مع Retry ----------------
async function fetchJSONWithRetry(url, retries = 2) {
  for (let i = 0; i <= retries; i++) {
    try { const res = await fetch(url); return await res.json(); } 
    catch (e) { if (i === retries) return null; }
  }
}

// ---------------- تحقق من تحديث كل ملف JSON داخل الجديد.json ----------------
async function getJSONLastModified(url) {
  try {
    const res = await fetch(url, { method: "HEAD" });
    const last = res.headers.get("Last-Modified");
    return last ? new Date(last).getTime() : null;
  } catch (e) { console.error("خطأ عند قراءة Last-Modified:", e); return null; }
}
async function getStoredFileModified(url) {
  const ref = doc(db, "filesModified", encodeURIComponent(url));
  const snap = await getDoc(ref);
  return snap.exists() ? snap.data().lastModified : 0;
}
async function saveFileModified(url, value) {
  const ref = doc(db, "filesModified", encodeURIComponent(url));
  await setDoc(ref, { lastModified: value });
}

async function checkForUpdates() {
  showLoading();
  try {
    const res = await fetch("الجديد.json");
    const data = await res.json();
    const urls = data.animes;
    const updatedFiles = [];
    const fetchedEpisodes = [];

    for (const url of urls) {
      const stored = await getStoredFileModified(url);
      const remote = await getJSONLastModified(url);
      if (!remote) continue;
      if (stored !== remote) {
        const jsonData = await fetchJSONWithRetry(url);
        if (jsonData && jsonData.episodes) {
          jsonData.episodes.forEach(ep => {
            fetchedEpisodes.push({
              animeTitle: jsonData.animeTitle,
              image: ep.image,
              link: ep.link,
              number: ep.number,
              title: ep.title,
              date: ep.date || new Date().toISOString()
            });
          });
        }
        await saveFileModified(url, remote);
        updatedFiles.push(url);
      }
    }

    if (updatedFiles.length > 0) {
      let oldEpisodes = await loadAllParts();
      const newOrUpdated = fetchedEpisodes.filter(ep => {
        const old = oldEpisodes.find(o => o.link === ep.link);
        return !old || JSON.stringify(old) !== JSON.stringify(ep);
      });
      const merged = [
        ...newOrUpdated,
        ...oldEpisodes.filter(o => !newOrUpdated.some(n => n.link === o.link))
      ];
      merged.sort((a, b) => new Date(b.date) - new Date(a.date));
      await uploadEpisodesInParts(merged);
    }

  } catch(e){ console.error("❌ خطأ في checkForUpdates:", e); }

  allEpisodes = await loadAllParts();
  const currentPage = getPageFromURL();
  renderPage(currentPage);
  setupPagination(allEpisodes.length, currentPage);
  hideLoading();
}

// ---------------- تشغيل init ----------------
async function init() {
  showLoading();
  allEpisodes = await loadAllParts();
  const currentPage = getPageFromURL();
  renderPage(currentPage);
  setupPagination(allEpisodes.length, currentPage);
  hideLoading();
}
init();
window.checkForUpdates = checkForUpdates;

</script>

<script>
fetch('navbar.html')
  .then(res=>res.text())
  .then(data=>document.getElementById('navbar-container').innerHTML=data)
  .catch(err=>console.error("خطأ في تحميل شريط التنقل:", err));
</script>

</main>
</body>
</html>
