<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>أحدث حلقات</title>
<link rel="stylesheet" href="/CSS/style.css" />
<script src="navbar.js" defer></script>
<link rel="icon" href="https://abdo12249.github.io/1/navbar/favicon.ico" type="image/x-icon" />

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<style>
/* Pagination styling */
.pagination { display: flex; justify-content: center; flex-wrap: wrap; gap: 8px; margin: 20px 0; }
.pagination button { padding: 6px 12px; background-color: var(--primary-color, #ef4444); color: white; border: none; cursor: pointer; border-radius: 6px; transition: background-color 0.3s ease; }
.pagination button:hover { background-color: #dc2626; }
.pagination button.active { background-color: #b91c1c; }
.pagination span { padding: 6px 12px; color: #888; }

/* Loading overlay */
.loading-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background-color: rgba(0,0,0,0.7); display: flex; flex-direction: column;
  justify-content: center; align-items: center; z-index: 1000; color: white; font-size: 1.2em;
}
.spinner {
  border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid #fff;
  border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
.anime-image img.loaded { opacity: 1; }

/* small helper for debug buttons (optional) */
.controls { display:flex; gap:8px; justify-content:center; margin:12px 0; }
.controls button { padding:8px 12px; border-radius:6px; border:none; cursor:pointer; background:#ef4444; color:#fff;}
.controls button:hover{opacity:0.9;}
</style>
</head>
<body>

<div id="navbar-container"></div>

<main>
  <div class="section-header">
    <h1>أحدث حلقات</h1>
  </div>

  <!-- optional debug controls (يمكن حذفه لاحقًا) -->
  <div class="controls" aria-hidden="true">
    <button id="btn-update-all">تحقق من الجديد (الكل)</button>
    <button id="btn-update-sample">تحقق من روابط مخصصة (عينة)</button>
  </div>

  <div class="anime-grid" id="animeGrid"></div>
  <div class="pagination" id="pagination"></div>

  <!-- Loading overlay -->
  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="spinner"></div>
    <span id="loadingText">جاري تحميل الأنمي...</span>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
import { getFirestore, collection, getDocs, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";

/* ---------------- Firebase config ---------------- */
const firebaseConfig = {
  apiKey: "AIzaSyAQpXUUOLyN2B6IWGb5Ru2Dl8NZPNimTEg",
  authDomain: "wep1-25124.firebaseapp.com",
  databaseURL: "https://wep1-25124-default-rtdb.firebaseio.com",
  projectId: "wep1-25124",
  storageBucket: "wep1-25124.firebasestorage.app",
  messagingSenderId: "400763524699",
  appId: "1:400763524699:web:b3d5b77815de059ad9117e",
  measurementId: "G-ER2GCC7BK4"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ---------------- constants / state ---------------- */
const maxItemsPerPage = 20;
const EPISODES_PER_PART = 500;
let allEpisodes = [];

/* ---------------- UI helpers ---------------- */
function showLoading(text = "جاري تحميل الأنمي...") {
  const el = document.getElementById("loadingOverlay");
  const txt = document.getElementById("loadingText");
  if (txt) txt.textContent = text;
  el.style.display = "flex";
}
function hideLoading() { document.getElementById("loadingOverlay").style.display = "none"; }

/* ---------------- pagination & render ---------------- */
function getPageFromURL() {
  const params = new URLSearchParams(window.location.search);
  return parseInt(params.get("page")) || 1;
}
function updateURL(page) {
  const url = new URL(window.location.href);
  url.searchParams.set("page", page);
  window.history.pushState({}, "", url);
}
function setupLazyLoading() {
  const lazyImages = document.querySelectorAll("img[data-src]");
  const observer = new IntersectionObserver((entries, obs) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        img.removeAttribute("data-src");
        obs.unobserve(img);
      }
    });
  }, { rootMargin: "100px" });
  lazyImages.forEach(img => observer.observe(img));
}
function renderPage(pageNumber) {
  updateURL(pageNumber);
  const animeGrid = document.getElementById("animeGrid");
  animeGrid.innerHTML = "";
  const startIndex = (pageNumber - 1) * maxItemsPerPage;
  const endIndex = startIndex + maxItemsPerPage;
  const episodesToShow = allEpisodes.slice(startIndex, endIndex);

  episodesToShow.forEach(ep => {
    const card = document.createElement("div");
    card.className = "anime-card";
    card.innerHTML = `
      <div class="anime-image">
        <img data-src="${ep.image}" alt="${ep.animeTitle}" loading="lazy">
      </div>
      <div class="anime-info">
        <h3>${ep.animeTitle}</h3>
        <div class="anime-meta">
          <span>${ep.title}</span>
          <a href="${ep.link}" class="watch-button" target="_blank" rel="noopener">شاهد الآن</a>
        </div>
      </div>`;
    animeGrid.appendChild(card);
  });

  setupLazyLoading();

  document.querySelectorAll(".pagination button").forEach(b => b.classList.remove("active"));
  const activeBtn = document.querySelector(`.pagination button[data-page="${pageNumber}"]`);
  if (activeBtn) activeBtn.classList.add("active");
  window.scrollTo({ top: 0, behavior: "smooth" });
}
function setupPagination(totalItems, currentPage = 1) {
  const pageCount = Math.max(1, Math.ceil(totalItems / maxItemsPerPage));
  const pagination = document.getElementById("pagination");
  pagination.innerHTML = "";
  const maxVisible = 5;
  let start = Math.max(1, currentPage - Math.floor(maxVisible / 2));
  let end = Math.min(start + maxVisible - 1, pageCount);
  if (end - start < maxVisible - 1) start = Math.max(1, end - maxVisible + 1);

  if (currentPage > 1) {
    const prev = document.createElement("button");
    prev.textContent = "السابق";
    prev.onclick = () => { renderPage(currentPage - 1); setupPagination(totalItems, currentPage - 1); };
    pagination.appendChild(prev);
  }

  for (let i = start; i <= end; i++) {
    const btn = document.createElement("button");
    btn.textContent = i;
    btn.setAttribute("data-page", i);
    if (i === currentPage) btn.classList.add("active");
    btn.onclick = () => { renderPage(i); setupPagination(totalItems, i); };
    pagination.appendChild(btn);
  }

  if (currentPage < pageCount) {
    const next = document.createElement("button");
    next.textContent = "التالي";
    next.onclick = () => { renderPage(currentPage + 1); setupPagination(totalItems, currentPage + 1); };
    pagination.appendChild(next);
  }
}

/* ---------------- Firebase parts handling ---------------- */
async function loadAllParts() {
  const snapshot = await getDocs(collection(db, "episodes"));
  const partsArray = [];
  snapshot.forEach(docSnap => {
    if (docSnap.id.startsWith("part")) {
      const partNumber = parseInt(docSnap.id.replace("part",""),10);
      partsArray.push({ partNumber, episodes: docSnap.data().episodes });
    }
  });
  partsArray.sort((a,b)=>a.partNumber-b.partNumber);
  const mergedEpisodes = [];
  partsArray.forEach(part=>mergedEpisodes.push(...part.episodes));
  return mergedEpisodes;
}

async function uploadEpisodesInParts(episodes) {
  // ترتب ثم تقسّم وترفع كل جزء (Firestore)
  episodes.sort((a, b) => new Date(b.date) - new Date(a.date));
  const totalParts = Math.ceil(episodes.length / EPISODES_PER_PART);
  for(let i=0;i<totalParts;i++){
    const start = i*EPISODES_PER_PART;
    const end = start+EPISODES_PER_PART;
    const partEpisodes = episodes.slice(start,end);
    const partDocRef = doc(db,"episodes",`part${i+1}`);
    const existing = await getDoc(partDocRef);
    if(existing.exists()){
      const oldData = existing.data().episodes;
      const changed = JSON.stringify(oldData) !== JSON.stringify(partEpisodes);
      if(!changed){ console.log(`⏭️ الجزء part${i+1} لم يتغير.`); continue; }
    }
    await setDoc(partDocRef,{episodes: partEpisodes, updatedAt: Date.now()});
    console.log(`✅ تم تحديث أو إنشاء part${i+1} (${partEpisodes.length} حلقة)`);
  }
}

/* ---------------- fetch مع Retry ---------------- */
async function fetchJSONWithRetry(url, retries = 2) {
  for (let i = 0; i <= retries; i++) {
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      console.warn(`fetch failed (${url}) attempt ${i+1}:`, e);
      if (i === retries) return null;
      // صغير تأخير قبل محاولة التالية
      await new Promise(r => setTimeout(r, 300 * (i+1)));
    }
  }
}

/* ---------------- fetch مع Concurrency Limit (workers) ----------------
   urls: array of urls
   limit: عدد الطلبات المتزامنة
*/
async function fetchWithConcurrencyLimit(urls, limit = 3) {
  const results = [];
  const queue = urls.slice(); // clone
  async function worker() {
    while (queue.length > 0) {
      const url = queue.shift();
      const data = await fetchJSONWithRetry(url, 2);
      results.push({ url, data });
    }
  }
  const workers = Array.from({length: Math.max(1, limit)}, () => worker());
  await Promise.all(workers);
  // نحول إلى مصفوفة البيانات (نحتفظ بالرابط أيضاً عند الحاجة)
  return results.map(r => r.data);
}

/* ======================  
   checkForUpdates (الكل)
   ====================== */
async function checkForUpdates() {
  showLoading("جاري التحقق من كل الروابط في الجديد.json...");
  let existingEpisodes = await loadAllParts();

  try {
    const res = await fetch("الجديد.json");
    if (!res.ok) throw new Error(`فشل تحميل الجديد.json (${res.status})`);
    const data = await res.json();
    const animeLinks = Array.isArray(data.animes) ? data.animes : [];

    if (animeLinks.length === 0) {
      alert("⚠️ الجديد.json لا يحتوي على روابط (animes فارغة).");
      hideLoading();
      return;
    }

    // جلب بيانات كل رابط (بحد concurrent معقول)
    const fetchedAnimeData = await fetchWithConcurrencyLimit(animeLinks, 3);
    const fetchedEpisodes = [];

    fetchedAnimeData.forEach(animeData => {
      if(!animeData) return;
      if (!Array.isArray(animeData.episodes)) return;
      animeData.episodes.forEach(ep => {
        fetchedEpisodes.push({
          animeTitle: animeData.animeTitle || '',
          image: ep.image || '',
          link: ep.link || '',
          number: ep.number || '',
          title: ep.title || '',
          date: ep.date || new Date().toISOString()
        });
      });
    });

    const newOrUpdated = fetchedEpisodes.filter(ep=>{
      const old = existingEpisodes.find(o=>o.link===ep.link);
      return !old || JSON.stringify(old)!==JSON.stringify(ep);
    });

    if(newOrUpdated.length>0){
      console.log(`✨ تم اكتشاف ${newOrUpdated.length} تحديث أو حلقة جديدة`);
      const merged = [...newOrUpdated, ...existingEpisodes.filter(o=>!newOrUpdated.some(n=>n.link===o.link))];
      merged.sort((a,b)=>new Date(b.date)-new Date(a.date));
      await uploadEpisodesInParts(merged);
      alert(`✨ تم تحديث ${newOrUpdated.length} حلقة/تحديث.`);
    } else {
      console.log("✅ لا توجد تحديثات أو تغييرات.");
      alert("✅ لا توجد تحديثات أو تغييرات.");
    }

  } catch(e){
    console.error("❌ حدث خطأ عند التحقق من الجديد:", e);
    alert("❌ حدث خطأ أثناء التحقق. افتح الكونسول للمزيد من التفاصيل.");
  }

  allEpisodes = await loadAllParts();
  const currentPage = getPageFromURL();
  renderPage(currentPage);
  setupPagination(allEpisodes.length, currentPage);
  hideLoading();
}

/* =========================================
   checkForUpdatesCustom(["url1.json", "url2.json"]); (روابط محددة فقط)
   - يقبل array من الروابط 
   - يقبل فقط الروابط الموجودة داخل الجديد.json (validation)
   ========================================= */
async function checkForUpdatesCustom(customLinks = []) {
  showLoading("جاري التحقق من الروابط المحددة...");
  let existingEpisodes = await loadAllParts();

  try {
    if (!Array.isArray(customLinks) || customLinks.length === 0) {
      alert("⚠️ لم يتم تمرير روابط للتحديث.");
      hideLoading();
      return;
    }

    // تحميل الجديد.json للتحقق من وجود الروابط داخلها
    const res = await fetch("الجديد.json");
    if (!res.ok) throw new Error(`فشل تحميل الجديد.json (${res.status})`);
    const data = await res.json();
    const allLinks = Array.isArray(data.animes) ? data.animes : [];

    // valid / invalid
    const validLinks = customLinks.filter(link => allLinks.includes(link));
    const invalidLinks = customLinks.filter(link => !allLinks.includes(link));

    if (invalidLinks.length > 0) {
      const msg = "⚠️ الروابط التالية غير موجودة داخل الجديد.json:\n" + invalidLinks.join("\n");
      console.warn(msg);
      alert(msg);
    }

    if (validLinks.length === 0) {
      hideLoading();
      return;
    }

    const fetchedAnimeData = await fetchWithConcurrencyLimit(validLinks, 3);
    const fetchedEpisodes = [];

    fetchedAnimeData.forEach(animeData => {
      if(!animeData) return;
      if (!Array.isArray(animeData.episodes)) return;
      animeData.episodes.forEach(ep => {
        fetchedEpisodes.push({
          animeTitle: animeData.animeTitle || '',
          image: ep.image || '',
          link: ep.link || '',
          number: ep.number || '',
          title: ep.title || '',
          date: ep.date || new Date().toISOString()
        });
      });
    });

    const newOrUpdated = fetchedEpisodes.filter(ep=>{
      const old = existingEpisodes.find(o=>o.link===ep.link);
      return !old || JSON.stringify(old)!==JSON.stringify(ep);
    });

    if(newOrUpdated.length>0){
      console.log(`✨ تم اكتشاف ${newOrUpdated.length} تحديث أو حلقة جديدة (روابط مخصصة)`);
      const merged = [...newOrUpdated, ...existingEpisodes.filter(o=>!newOrUpdated.some(n=>n.link===o.link))];
      merged.sort((a,b)=>new Date(b.date)-new Date(a.date));
      await uploadEpisodesInParts(merged);
      alert(`✨ تم تحديث ${newOrUpdated.length} حلقة/تحديث (روابط مخصصة).`);
    } else {
      console.log("✅ لا توجد تحديثات أو تغييرات (روابط مخصصة).");
      alert("✅ لا توجد تحديثات أو تغييرات (روابط مخصصة).");
    }

  } catch(e){
    console.error("❌ خطأ داخل checkForUpdatesCustom:", e);
    alert("❌ حدث خطأ أثناء التحقق من الروابط المخصصة. افتح الكونسول للمزيد من التفاصيل.");
  }

  allEpisodes = await loadAllParts();
  const currentPage = getPageFromURL();
  renderPage(currentPage);
  setupPagination(allEpisodes.length, currentPage);
  hideLoading();
}

/* make global */
window.checkForUpdates = checkForUpdates;
window.checkForUpdatesCustom = checkForUpdatesCustom;

/* ---------------- init on page load ---------------- */
async function init() {
  showLoading("جاري تحميل الحلقات...");
  allEpisodes = await loadAllParts();
  const currentPage = getPageFromURL();
  renderPage(currentPage);
  setupPagination(allEpisodes.length, currentPage);
  hideLoading();
}
init();

/* ---------------- optional debug buttons handlers ---------------- */
document.getElementById("btn-update-all").addEventListener("click", () => {
  checkForUpdates();
});
document.getElementById("btn-update-sample").addEventListener("click", async () => {
  // مثال توضيحي: استبدل هذه الروابط بروابط من الجديد.json عند التجربة
  const sample = [
    // "https://example.com/anime/one-piece.json",
    // "https://example.com/anime/naruto.json"
  ];
  // إذا أردت تجربة: ضع في sample بعض الروابط الموجودة في الجديد.json ثم اضغط الزر
  await checkForUpdatesCustom(sample);
});
</script>

<script>
fetch('navbar.html')
  .then(res=>res.text())
  .then(data=>document.getElementById('navbar-container').innerHTML=data)
  .catch(err=>console.error("خطأ في تحميل شريط التنقل:", err));
</script>

</main>
</body>
</html>

