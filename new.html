<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Ø£Ø­Ø¯Ø« Ø­Ù„Ù‚Ø§Øª</title>
<link rel="stylesheet" href="/CSS/style.css" />
<script src="navbar.js" defer></script>
<link rel="icon" href="https://abdo12249.github.io/1/navbar/favicon.ico" type="image/x-icon" />

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<style>
/* Pagination styling */
.pagination { display: flex; justify-content: center; flex-wrap: wrap; gap: 8px; margin: 20px 0; }
.pagination button { padding: 6px 12px; background-color: var(--primary-color, #ef4444); color: white; border: none; cursor: pointer; border-radius: 6px; transition: background-color 0.3s ease; }
.pagination button:hover { background-color: #dc2626; }
.pagination button.active { background-color: #b91c1c; }
.pagination span { padding: 6px 12px; color: #888; }

/* Loading overlay */
.loading-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background-color: rgba(0,0,0,0.7); display: flex; flex-direction: column;
  justify-content: center; align-items: center; z-index: 1000; color: white; font-size: 1.2em;
}
.spinner {
  border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid #fff;
  border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
.anime-image img.loaded { opacity: 1; }

/* small helper for debug buttons (optional) */
.controls { display:flex; gap:8px; justify-content:center; margin:12px 0; }
.controls button { padding:8px 12px; border-radius:6px; border:none; cursor:pointer; background:#ef4444; color:#fff;}
.controls button:hover{opacity:0.9;}
</style>
</head>
<body>

<div id="navbar-container"></div>

<main>
  <div class="section-header">
    <h1>Ø£Ø­Ø¯Ø« Ø­Ù„Ù‚Ø§Øª</h1>
  </div>

  <div class="anime-grid" id="animeGrid"></div>
  <div class="pagination" id="pagination"></div>

  <!-- Loading overlay -->
  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="spinner"></div>
    <span id="loadingText">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠ...</span>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
import { getFirestore, collection, getDocs, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";

/* ---------------- Firebase config ---------------- */
const firebaseConfig = {
  apiKey: "AIzaSyAQpXUUOLyN2B6IWGb5Ru2Dl8NZPNimTEg",
  authDomain: "wep1-25124.firebaseapp.com",
  databaseURL: "https://wep1-25124-default-rtdb.firebaseio.com",
  projectId: "wep1-25124",
  storageBucket: "wep1-25124.firebasestorage.app",
  messagingSenderId: "400763524699",
  appId: "1:400763524699:web:b3d5b77815de059ad9117e",
  measurementId: "G-ER2GCC7BK4"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ---------------- constants / state ---------------- */
const maxItemsPerPage = 20;
const EPISODES_PER_PART = 500;
let allEpisodes = [];

/* ---------------- UI helpers ---------------- */
function showLoading(text = "Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠ...") {
  const el = document.getElementById("loadingOverlay");
  const txt = document.getElementById("loadingText");
  if (txt) txt.textContent = text;
  el.style.display = "flex";
}
function hideLoading() { document.getElementById("loadingOverlay").style.display = "none"; }

/* ---------------- pagination & render ---------------- */
function getPageFromURL() {
  const params = new URLSearchParams(window.location.search);
  return parseInt(params.get("page")) || 1;
}
function updateURL(page) {
  const url = new URL(window.location.href);
  url.searchParams.set("page", page);
  window.history.pushState({}, "", url);
}
function setupLazyLoading() {
  const lazyImages = document.querySelectorAll("img[data-src]");
  const observer = new IntersectionObserver((entries, obs) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        img.removeAttribute("data-src");
        obs.unobserve(img);
      }
    });
  }, { rootMargin: "100px" });
  lazyImages.forEach(img => observer.observe(img));
}
function renderPage(pageNumber) {
  updateURL(pageNumber);
  const animeGrid = document.getElementById("animeGrid");
  animeGrid.innerHTML = "";
  const startIndex = (pageNumber - 1) * maxItemsPerPage;
  const endIndex = startIndex + maxItemsPerPage;
  const episodesToShow = allEpisodes.slice(startIndex, endIndex);

  episodesToShow.forEach(ep => {
    const card = document.createElement("div");
    card.className = "anime-card";
    card.innerHTML = `
      <div class="anime-image">
        <img data-src="${ep.image}" alt="${ep.animeTitle}" loading="lazy">
      </div>
      <div class="anime-info">
        <h3>${ep.animeTitle}</h3>
        <div class="anime-meta">
          <span>${ep.title}</span>
          <a href="${ep.link}" class="watch-button" target="_blank" rel="noopener">Ø´Ø§Ù‡Ø¯ Ø§Ù„Ø¢Ù†</a>
        </div>
      </div>`;
    animeGrid.appendChild(card);
  });

  setupLazyLoading();

  document.querySelectorAll(".pagination button").forEach(b => b.classList.remove("active"));
  const activeBtn = document.querySelector(`.pagination button[data-page="${pageNumber}"]`);
  if (activeBtn) activeBtn.classList.add("active");
  window.scrollTo({ top: 0, behavior: "smooth" });
}
function setupPagination(totalItems, currentPage = 1) {
  const pageCount = Math.max(1, Math.ceil(totalItems / maxItemsPerPage));
  const pagination = document.getElementById("pagination");
  pagination.innerHTML = "";
  const maxVisible = 5;
  let start = Math.max(1, currentPage - Math.floor(maxVisible / 2));
  let end = Math.min(start + maxVisible - 1, pageCount);
  if (end - start < maxVisible - 1) start = Math.max(1, end - maxVisible + 1);

  if (currentPage > 1) {
    const prev = document.createElement("button");
    prev.textContent = "Ø§Ù„Ø³Ø§Ø¨Ù‚";
    prev.onclick = () => { renderPage(currentPage - 1); setupPagination(totalItems, currentPage - 1); };
    pagination.appendChild(prev);
  }

  for (let i = start; i <= end; i++) {
    const btn = document.createElement("button");
    btn.textContent = i;
    btn.setAttribute("data-page", i);
    if (i === currentPage) btn.classList.add("active");
    btn.onclick = () => { renderPage(i); setupPagination(totalItems, i); };
    pagination.appendChild(btn);
  }

  if (currentPage < pageCount) {
    const next = document.createElement("button");
    next.textContent = "Ø§Ù„ØªØ§Ù„ÙŠ";
    next.onclick = () => { renderPage(currentPage + 1); setupPagination(totalItems, currentPage + 1); };
    pagination.appendChild(next);
  }
}

/* ---------------- Firebase parts handling ---------------- */
async function loadAllParts() {
  const snapshot = await getDocs(collection(db, "episodes"));
  const partsArray = [];
  snapshot.forEach(docSnap => {
    if (docSnap.id.startsWith("part")) {
      const partNumber = parseInt(docSnap.id.replace("part",""),10);
      partsArray.push({ partNumber, episodes: docSnap.data().episodes });
    }
  });
  partsArray.sort((a,b)=>a.partNumber-b.partNumber);
  const mergedEpisodes = [];
  partsArray.forEach(part=>mergedEpisodes.push(...part.episodes));
  return mergedEpisodes;
}

async function uploadEpisodesInParts(episodes) {
  episodes.sort((a,b)=>new Date(b.date)-new Date(a.date));
  const totalParts = Math.ceil(episodes.length / EPISODES_PER_PART);
  
  for(let i=0;i<totalParts;i++){
    const start = i*EPISODES_PER_PART;
    const end = start+EPISODES_PER_PART;
    const partEpisodes = episodes.slice(start,end);
    const partDocRef = doc(db,"episodes",`part${i+1}`);
    const existing = await getDoc(partDocRef);

    if(existing.exists()){
      const oldData = existing.data().episodes;
      const newEpisodes = partEpisodes.filter(ep=>{
        return !oldData.some(old=>old.link===ep.link && JSON.stringify(old)===JSON.stringify(ep));
      });
      if(newEpisodes.length===0){
        console.log(`â­ï¸ Ø§Ù„Ø¬Ø²Ø¡ part${i+1} Ù„Ù… ÙŠØªØºÙŠØ±.`);
        continue;
      }
      await setDoc(partDocRef,{episodes:[...oldData,...newEpisodes], updatedAt: Date.now()});
      console.log(`âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« part${i+1} Ø¨Ø¥Ø¶Ø§ÙØ© ${newEpisodes.length} Ø­Ù„Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø©`);
    } else {
      await setDoc(partDocRef,{episodes:partEpisodes, updatedAt: Date.now()});
      console.log(`âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ part${i+1} (${partEpisodes.length} Ø­Ù„Ù‚Ø©)`);
    }
  }
}

/* ---------------- fetch Ù…Ø¹ Retry ---------------- */
async function fetchJSONWithRetry(url, retries = 2) {
  for (let i = 0; i <= retries; i++) {
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      console.warn(`fetch failed (${url}) attempt ${i+1}:`, e);
      if (i === retries) return null;
      await new Promise(r => setTimeout(r, 300 * (i+1)));
    }
  }
}

/* ---------------- fetch Ù…Ø¹ Concurrency Limit ---------------- */
async function fetchWithConcurrencyLimit(urls, limit = 3) {
  const results = [];
  const queue = urls.slice();
  async function worker() {
    while (queue.length > 0) {
      const url = queue.shift();
      const data = await fetchJSONWithRetry(url, 2);
      results.push({ url, data });
    }
  }
  const workers = Array.from({length: Math.max(1, limit)}, () => worker());
  await Promise.all(workers);
  return results.map(r => r.data);
}

/* ======================  
   checkForUpdates
   ====================== */
async function checkForUpdates() {
  showLoading("Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· ÙÙŠ Ø§Ù„Ø¬Ø¯ÙŠØ¯.json...");
  let existingEpisodes = await loadAllParts();

  try {
    const res = await fetch("Ø§Ù„Ø¬Ø¯ÙŠØ¯.json");
    if (!res.ok) throw new Error(`ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯.json (${res.status})`);
    const data = await res.json();
    const animeLinks = Array.isArray(data.animes) ? data.animes : [];

    if (animeLinks.length === 0) {
      alert("âš ï¸ Ø§Ù„Ø¬Ø¯ÙŠØ¯.json Ù„Ø§ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø· (animes ÙØ§Ø±ØºØ©).");
      hideLoading();
      return;
    }

    const fetchedAnimeData = await fetchWithConcurrencyLimit(animeLinks, 3);
    const fetchedEpisodes = [];

    fetchedAnimeData.forEach(animeData => {
      if(!animeData) return;
      if (!Array.isArray(animeData.episodes)) return;
      animeData.episodes.forEach(ep => {
        fetchedEpisodes.push({
          animeTitle: animeData.animeTitle || '',
          image: ep.image || '',
          link: ep.link || '',
          number: ep.number || '',
          title: ep.title || '',
          date: ep.date || new Date().toISOString()
        });
      });
    });

    const newOrUpdated = fetchedEpisodes.filter(ep=>{
      const old = existingEpisodes.find(o=>o.link===ep.link);
      return !old || JSON.stringify(old)!==JSON.stringify(ep);
    });

    if(newOrUpdated.length>0){
      console.log(`âœ¨ ØªÙ… Ø§ÙƒØªØ´Ø§Ù ${newOrUpdated.length} ØªØ­Ø¯ÙŠØ« Ø£Ùˆ Ø­Ù„Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø©`);
      const merged = [...newOrUpdated, ...existingEpisodes.filter(o=>!newOrUpdated.some(n=>n.link===o.link))];
      merged.sort((a,b)=>new Date(b.date)-new Date(a.date));
      await uploadEpisodesInParts(merged);
      alert(`âœ¨ ØªÙ… ØªØ­Ø¯ÙŠØ« ${newOrUpdated.length} Ø­Ù„Ù‚Ø©/ØªØ­Ø¯ÙŠØ«.`);
    } else {
      console.log("âœ… Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø£Ùˆ ØªØºÙŠÙŠØ±Ø§Øª.");
      alert("âœ… Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø£Ùˆ ØªØºÙŠÙŠØ±Ø§Øª.");
    }

  } catch(e){
    console.error("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯:", e);
    alert("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚. Ø§ÙØªØ­ Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„ Ù„Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªÙØ§ØµÙŠÙ„.");
  }

  allEpisodes = await loadAllParts();
  const currentPage = getPageFromURL();
  renderPage(currentPage);
  setupPagination(allEpisodes.length, currentPage);
  hideLoading();
}

/* =========================================
   checkForUpdatesCustom
   ========================================= */
async function checkForUpdatesCustom(customLinks = []) {
  showLoading("Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©...");
  let existingEpisodes = await loadAllParts();

  try {
    if (!Array.isArray(customLinks) || customLinks.length === 0) {
      alert("âš ï¸ Ù„Ù… ÙŠØªÙ… ØªÙ…Ø±ÙŠØ± Ø±ÙˆØ§Ø¨Ø· Ù„Ù„ØªØ­Ø¯ÙŠØ«.");
      hideLoading();
      return;
    }

    const res = await fetch("Ø§Ù„Ø¬Ø¯ÙŠØ¯.json");
    if (!res.ok) throw new Error(`ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯.json (${res.status})`);
    const data = await res.json();
    const allLinks = Array.isArray(data.animes) ? data.animes : [];

    const validLinks = customLinks.filter(link => allLinks.includes(link));
    const invalidLinks = customLinks.filter(link => !allLinks.includes(link));

    if (invalidLinks.length > 0) {
      const msg = "âš ï¸ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØªØ§Ù„ÙŠØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯.json:\n" + invalidLinks.join("\n");
      console.warn(msg);
      alert(msg);
    }

    if (validLinks.length === 0) {
      hideLoading();
      return;
    }

    const fetchedAnimeData = await fetchWithConcurrencyLimit(validLinks, 3);
    const fetchedEpisodes = [];

    fetchedAnimeData.forEach(animeData => {
      if(!animeData) return;
      if (!Array.isArray(animeData.episodes)) return;
      animeData.episodes.forEach(ep => {
        fetchedEpisodes.push({
          animeTitle: animeData.animeTitle || '',
          image: ep.image || '',
          link: ep.link || '',
          number: ep.number || '',
          title: ep.title || '',
          date: ep.date || new Date().toISOString()
        });
      });
    });

    const newOrUpdated = fetchedEpisodes.filter(ep=>{
      const old = existingEpisodes.find(o=>o.link===ep.link);
      return !old || JSON.stringify(old)!==JSON.stringify(ep);
    });

    if(newOrUpdated.length>0){
      console.log(`âœ¨ ØªÙ… Ø§ÙƒØªØ´Ø§Ù ${newOrUpdated.length} ØªØ­Ø¯ÙŠØ« Ø£Ùˆ Ø­Ù„Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø© (Ø±ÙˆØ§Ø¨Ø· Ù…Ø®ØµØµØ©)`);
      const merged = [...newOrUpdated, ...existingEpisodes.filter(o=>!newOrUpdated.some(n=>n.link===o.link))];
      merged.sort((a,b)=>new Date(b.date)-new Date(a.date));
      await uploadEpisodesInParts(merged);
      alert(`âœ¨ ØªÙ… ØªØ­Ø¯ÙŠØ« ${newOrUpdated.length} Ø­Ù„Ù‚Ø©/ØªØ­Ø¯ÙŠØ« (Ø±ÙˆØ§Ø¨Ø· Ù…Ø®ØµØµØ©).`);
    } else {
      console.log("âœ… Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø£Ùˆ ØªØºÙŠÙŠØ±Ø§Øª (Ø±ÙˆØ§Ø¨Ø· Ù…Ø®ØµØµØ©).");
      alert("âœ… Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø£Ùˆ ØªØºÙŠÙŠØ±Ø§Øª (Ø±ÙˆØ§Ø¨Ø· Ù…Ø®ØµØµØ©).");
    }

  } catch(e){
    console.error("âŒ Ø®Ø·Ø£ Ø¯Ø§Ø®Ù„ checkForUpdatesCustom:", e);
    alert("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù…Ø®ØµØµØ©. Ø§ÙØªØ­ Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„ Ù„Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªÙØ§ØµÙŠÙ„.");
  }

  allEpisodes = await loadAllParts();
  const currentPage = getPageFromURL();
  renderPage(currentPage);
  setupPagination(allEpisodes.length, currentPage);
  hideLoading();
}

/* Ø§Ø¬Ø¹Ù„Ù‡Ø§ Global */
window.checkForUpdates = checkForUpdates;
window.checkForUpdatesCustom = checkForUpdatesCustom;

/* ==========================================================
   ğŸ”¥ ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù test1/checkForUpdatesCustom.js ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
   ========================================================== */
async function loadCustomUpdateFile() {
  const customScriptURL = "/test1/checkForUpdatesCustom.js";

  try {
    const res = await fetch(customScriptURL, { method: "HEAD" });

    if (res.ok) {
      console.log("ğŸ“Œ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ test1/checkForUpdatesCustom.js â€” ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡...");

      const script = document.createElement("script");
      script.src = customScriptURL + "?v=" + Date.now();
      script.onload = () => console.log("âœ… ØªÙ… ØªØ´ØºÙŠÙ„ checkForUpdatesCustom.js");
      script.onerror = () => console.error("âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ checkForUpdatesCustom.js");

      document.body.appendChild(script);
    } else {
      console.warn("âš ï¸ Ù…Ù„Ù checkForUpdatesCustom.js ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ â€” Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¨Ø¯ÙˆÙ† ØªØ´ØºÙŠÙ„Ù‡.");
    }
  } catch (err) {
    console.warn("âš ï¸ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ test1/checkForUpdatesCustom.js", err);
  }
}

/* ---------------- init on page load ---------------- */
async function init() {
  showLoading("Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø­Ù„Ù‚Ø§Øª...");
  allEpisodes = await loadAllParts();
  const currentPage = getPageFromURL();
  renderPage(currentPage);
  setupPagination(allEpisodes.length, currentPage);
  hideLoading();
}

/* â† Ù‡Ù†Ø§ Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© */
await loadCustomUpdateFile();
init();

/* ---------------- optional debug buttons ---------------- */
document.getElementById("btn-update-all")?.addEventListener("click", () => {
  checkForUpdates();
});
document.getElementById("btn-update-sample")?.addEventListener("click", async () => {
  const sample = [];
  await checkForUpdatesCustom(sample);
});
</script>

<script>
fetch('navbar.html')
  .then(res=>res.text())
  .then(data=>document.getElementById('navbar-container').innerHTML=data)
  .catch(err=>console.error("Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ†Ù‚Ù„:", err));
</script>

</main>
</body>
</html>


