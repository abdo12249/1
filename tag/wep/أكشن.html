<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>تصنيفات الأنمي</title>
  <link rel="stylesheet" href="../../CSS/style.css" />
  <script src="../../navbar.js" defer></script>
  <link rel="icon" href="https://abdo12249.github.io/1/navbar/favicon.ico" type="image/x-icon" />
  
</head>
<body>
  <div id="navbar-container"></div>

  <main>
    <div class="section-header">
      <h1>تصنيفات الأنمي</h1>
    </div>

    <!-- فلاتر الأنمي -->
    <div id="filters">
      <label>
        التصنيف:
        <select id="categorySelect" class="watch-button" onchange="applyFilters()">
          <option value="all">عرض الكل</option>
        </select>
      </label>

      <label>
        النوع:
        <select id="typeSelect" class="watch-button" onchange="applyFilters()">
          <option value="all">الكل</option>
        </select>
      </label>

      <label>
        الحالة:
        <select id="statusSelect" class="watch-button" onchange="applyFilters()">
          <option value="all">الكل</option>
        </select>
      </label>

      <label>
        الموسم:
        <select id="seasonSelect" class="watch-button" onchange="applyFilters()">
          <option value="all">الكل</option>
        </select>
      </label>

      <button onclick="resetFilters()" class="watch-button">إعادة ضبط الفلاتر</button>
    </div>

    <!-- شبكة الأنميات -->
    <div class="anime-grid" id="animeGrid"></div>

    <!-- أزرار الصفحات -->
    <div id="pagination" style="text-align: center; margin-top: 20px;"></div>
  </main>

  <!-- شاشة التحميل -->
  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="spinner"></div>
    <span>جاري تحميل الأنمي...</span>
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    let currentPage = parseInt(urlParams.get("page")) || 1;
    const itemsPerPage = 30;
    let allAnimes = []; // قائمة الأنميات بعد تطبيق الفلاتر
    let originalAnimes = []; // القائمة الأصلية لجميع الأنميات التي تم جلبها

    const cacheDuration = 24 * 60 * 60 * 1000; // 24 ساعة بالمللي ثانية

    // ثوابت IndexedDB
    const DB_NAME = 'AnimeCategoriesDB'; // اسم قاعدة بيانات مختلفة لتجنب التعارض
    const DB_VERSION = 1;
    const STORE_NAME = 'animeDataCache';
    const CACHE_KEY = 'cachedAnimeCategories';

    let db; // متغير للاحتفاظ بنسخة قاعدة بيانات IndexedDB

    // دالة لفتح قاعدة بيانات IndexedDB
    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME);
          }
        };

        request.onsuccess = (event) => {
          db = event.target.result;
          resolve(db);
        };

        request.onerror = (event) => {
          console.error("❌ خطأ في فتح IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // دالة لقراءة البيانات من IndexedDB
    async function readFromIndexedDB(key) {
      if (!db) {
        await openDatabase();
      }
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(key);

        request.onsuccess = (event) => {
          resolve(event.target.result);
        };

        request.onerror = (event) => {
          console.error("❌ خطأ في قراءة IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // دالة لكتابة البيانات إلى IndexedDB
    async function writeToIndexedDB(key, data) {
      if (!db) {
        await openDatabase();
      }
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put(data, key);

        request.onsuccess = () => {
          resolve();
        };

        request.onerror = (event) => {
          console.error("❌ خطأ في كتابة IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // دالة لإظهار شاشة التحميل
    function showLoading() {
      document.getElementById('loadingOverlay').style.display = 'flex';
    }

    // دالة لإخفاء شاشة التحميل
    function hideLoading() {
      document.getElementById('loadingOverlay').style.display = 'none';
    }

    function updatePageInURL(page) {
      // تجنب استخدام pushState في بيئات مثل blob: URLs لتجنب SecurityError
      if (window.location.protocol !== 'blob:') {
        const url = new URL(window.location);
        url.searchParams.set("page", page);
        url.searchParams.set("category", categorySelect.value);
        url.searchParams.set("type", typeSelect.value);
        url.searchParams.set("status", statusSelect.value);
        url.searchParams.set("season", seasonSelect.value);
        window.history.pushState({}, "", url);
      } else {
        console.warn("⚠️ تحديث URL معطل في بيئة blob: URL لتجنب أخطاء الأمان.");
      }
    }

    async function loadAnimeData() {
      showLoading(); // إظهار شاشة التحميل
      try {
        await openDatabase(); // التأكد من فتح IndexedDB

        const cachedObject = await readFromIndexedDB(CACHE_KEY);
        const now = Date.now();

        if (cachedObject && cachedObject.animes && (now - cachedObject.timestamp) < cacheDuration) {
          // استخدام البيانات المخزنة مؤقتًا إذا كانت موجودة وصالحة
          allAnimes = cachedObject.animes;
          originalAnimes = [...allAnimes];
          console.log("✅ تم تحميل بيانات الأنمي من IndexedDB.");
        } else {
          // جلب البيانات من الشبكة إذا لم تكن موجودة أو انتهت صلاحيتها
          console.log("🔄 جلب بيانات الأنمي جديدة وتخزينها مؤقتًا في IndexedDB.");
          const response = await fetch("https://abdo12249.github.io/1/test1/animes.json");
          if (!response.ok) throw new Error("❌ فشل تحميل animes.json");

          const data = await response.json();
          const animeList = Object.entries(data).map(([id, anime]) => ({ id, ...anime }));

          // حفظ البيانات في IndexedDB
          const cacheObject = {
            animes: animeList,
            timestamp: Date.now()
          };
          await writeToIndexedDB(CACHE_KEY, cacheObject);
          console.log("✅ تم حفظ بيانات الأنمي في IndexedDB.");

          allAnimes = animeList;
          originalAnimes = animeList;
        }

        generateFilterOptions();
        applyFilters(); // تطبيق الفلاتر وعرض الصفحة الأولى
      } catch (error) {
        console.error("❌ خطأ في تحميل الأنميات أو IndexedDB:", error);
        // في حالة فشل الجلب من الشبكة، حاول التحميل من IndexedDB كخيار احتياطي (حتى لو انتهت الصلاحية)
        try {
          const cachedData = await readFromIndexedDB(CACHE_KEY);
          if (cachedData && cachedData.animes) {
            allAnimes = cachedData.animes;
            originalAnimes = [...allAnimes];
            generateFilterOptions();
            applyFilters();
            console.log("⚠️ تم تحميل بيانات الأنمي من IndexedDB بسبب فشل الجلب من الشبكة.");
          } else {
            console.error("❌ لا توجد بيانات في IndexedDB. لا يمكن عرض أي أنميات.");
            // يمكنك عرض رسالة خطأ للمستخدم هنا إذا لم تتوفر بيانات
          }
        } catch (dbError) {
          console.error("❌ خطأ في قراءة IndexedDB بعد فشل الجلب:", dbError);
        }
      } finally {
        hideLoading(); // إخفاء شاشة التحميل
      }
    }

    function adjustPath(path) {
      // هذه الدالة تعدل المسار ليتناسب مع هيكل المجلدات الخاص بك.
      // إذا كانت صورك في نفس المجلد أو مسار نسبي مختلف، فقد تحتاج إلى تعديل هذا.
      return path.startsWith('../') ? path.replace('../', '../../') : path;
    }

    function displayAnime(anime) {
      const card = document.createElement('div');
      card.className = 'anime-card';
      const categories = anime.tags || anime.categories || [];

      card.innerHTML = `
        <a href="../../test1/Anime Page Dynamic.html?id=${anime.id}" style="text-decoration: none; color: inherit;">
          <div class="anime-image">
            <img src="${adjustPath(anime.image)}" alt="${anime.title}" loading="lazy" />
          </div>
          <div class="anime-info">
            <h3>${anime.title}</h3>
            <p>${anime.description || ''}</p>
          </div>
        </a>
      `;
      return card;
    }

    function showPage(page) {
      const animeGrid = document.getElementById('animeGrid');
      animeGrid.innerHTML = "";

      const startIndex = (page - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      const currentItems = allAnimes.slice(startIndex, endIndex);

      currentItems.forEach(anime => {
        const card = displayAnime(anime);
        animeGrid.appendChild(card);
      });

      // إضافة مراقب للتحميل التدريجي للصور بعد عرض الصفحة
      const lazyImages = document.querySelectorAll('#animeGrid img[loading="lazy"]');
      if ('IntersectionObserver' in window) {
        const observer = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const img = entry.target;
              img.classList.add('loaded');
              observer.unobserve(img);
            }
          });
        });
        lazyImages.forEach(img => observer.observe(img));
      } else {
        lazyImages.forEach(img => img.classList.add('loaded'));
      }
    }

    function createPagination() {
      const pagination = document.getElementById('pagination');
      pagination.innerHTML = "";

      const totalPages = Math.ceil(allAnimes.length / itemsPerPage);
      const maxVisiblePages = 5;

      if (currentPage > 1) {
        const prevBtn = document.createElement('button');
        prevBtn.textContent = "← السابق";
        prevBtn.className = "watch-button";
        prevBtn.onclick = () => {
          currentPage--;
          updatePageInURL(currentPage);
          showPage(currentPage);
          createPagination();
        };
        pagination.appendChild(prevBtn);
      }

      let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
      let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
      if (endPage - startPage < maxVisiblePages - 1) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }

      for (let i = startPage; i <= endPage; i++) {
        const button = document.createElement('button');
        button.textContent = i;
        button.className = "watch-button";
        if (i === currentPage) button.classList.add("active");
        button.onclick = () => {
          currentPage = i;
          updatePageInURL(currentPage);
          showPage(currentPage);
          createPagination();
        };
        pagination.appendChild(button);
      }

      if (endPage < totalPages) {
        const dots = document.createElement('span');
        dots.textContent = "...";
        dots.style.margin = "0 10px";
        pagination.appendChild(dots);

        const lastBtn = document.createElement('button');
        lastBtn.textContent = totalPages;
        lastBtn.className = "watch-button";
        lastBtn.onclick = () => {
          currentPage = totalPages;
          updatePageInURL(currentPage);
          showPage(currentPage);
          createPagination();
        };
        pagination.appendChild(lastBtn);
      }

      if (currentPage < totalPages) {
        const nextBtn = document.createElement('button');
        nextBtn.textContent = "التالي →";
        nextBtn.className = "watch-button";
        nextBtn.onclick = () => {
          currentPage++;
          updatePageInURL(currentPage);
          showPage(currentPage);
          createPagination();
        };
        pagination.appendChild(nextBtn);
      }
    }

    function generateFilterOptions() {
      const categorySet = new Set();
      const typeSet = new Set();
      const statusSet = new Set();
      const seasonMap = new Map();

      originalAnimes.forEach(anime => {
        (anime.tags || anime.categories || []).forEach(tag => categorySet.add(tag));
        if (anime.type) typeSet.add(anime.type);
        if (anime.status) statusSet.add(anime.status);
        if (anime.season) seasonMap.set(anime.season.trim(), true);
      });

      const seasonOrder = { "شتاء": 1, "ربيع": 2, "صيف": 3, "خريف": 4 };
      const sortedSeasons = [...seasonMap.keys()]
        .map(season => {
          const parts = season.split(" ");
          return { season, year: parseInt(parts[1]), order: seasonOrder[parts[0]] || 99 };
        })
        .sort((a, b) => a.year - b.year || a.order - b.order)
        .map(item => item.season);

      fillSelect("categorySelect", categorySet);
      fillSelect("typeSelect", typeSet);
      fillSelect("statusSelect", statusSet);
      fillSelect("seasonSelect", sortedSeasons);

      setFiltersFromURL();
    }

    function fillSelect(id, values) {
      const select = document.getElementById(id);
      // مسح الخيارات الحالية باستثناء "عرض الكل" أو "الكل"
      while (select.children.length > 1) {
        select.removeChild(select.lastChild);
      }
      values.forEach(value => {
        const option = document.createElement("option");
        option.value = value;
        option.textContent = value;
        select.appendChild(option);
      });
    }

    function setFiltersFromURL() {
      const category = urlParams.get("category");
      const type = urlParams.get("type");
      const status = urlParams.get("status");
      const season = urlParams.get("season");

      // التأكد من وجود العناصر قبل محاولة تعيين القيمة
      const categorySelect = document.getElementById("categorySelect");
      const typeSelect = document.getElementById("typeSelect");
      const statusSelect = document.getElementById("statusSelect");
      const seasonSelect = document.getElementById("seasonSelect");

      if (category && categorySelect && Array.from(categorySelect.options).some(opt => opt.value === category)) categorySelect.value = category;
      if (type && typeSelect && Array.from(typeSelect.options).some(opt => opt.value === type)) typeSelect.value = type;
      if (status && statusSelect && Array.from(statusSelect.options).some(opt => opt.value === status)) statusSelect.value = status;
      if (season && seasonSelect && Array.from(seasonSelect.options).some(opt => opt.value === season)) seasonSelect.value = season;
    }

    function applyFilters() {
      const selectedCategory = document.getElementById("categorySelect").value;
      const selectedType = document.getElementById("typeSelect").value;
      const selectedStatus = document.getElementById("statusSelect").value;
      const selectedSeason = document.getElementById("seasonSelect").value;

      allAnimes = originalAnimes.filter(anime => {
        const tags = anime.tags || anime.categories || [];
        const categoryMatch = selectedCategory === "all" || tags.includes(selectedCategory);
        const typeMatch = selectedType === "all" || anime.type === selectedType;
        const statusMatch = selectedStatus === "all" || anime.status === selectedStatus;
        const seasonMatch = selectedSeason === "all" || anime.season === selectedSeason;
        return categoryMatch && typeMatch && statusMatch && seasonMatch;
      });

      currentPage = parseInt(urlParams.get("page")) || 1; // إعادة تعيين الصفحة الحالية من URL بعد تطبيق الفلاتر
      showPage(currentPage);
      createPagination();
      updatePageInURL(currentPage); // تحديث URL بعد تطبيق الفلاتر
    }

    function resetFilters() {
      document.getElementById("categorySelect").value = "all";
      document.getElementById("typeSelect").value = "all";
      document.getElementById("statusSelect").value = "all";
      document.getElementById("seasonSelect").value = "all";
      currentPage = 1;
      applyFilters(); // تطبيق الفلاتر بعد إعادة الضبط
    }

    // بدء تحميل البيانات عند تحميل الصفحة
    loadAnimeData();
  </script>

  <script>
    fetch('../../navbar.html')
      .then(response => response.text())
      .then(data => document.getElementById('navbar-container').innerHTML = data)
      .catch(error => console.error('❌ خطأ في تحميل الشريط العلوي:', error));
  </script>
</body>
</html>
